from base import UI_GUI
from PyQt5 import QtCore

# from PyQt5.QtGui import QTextCharFormat


class APP_GUI(UI_GUI):
    def __init__(self, window):
        self.MainWindow = window
        print(len(self.config["modules"]))
        self.length = (
            531  # Hardcoded but should be proportional to the number of modules to load
        )

        # Setup up stream Designer built UI
        self.setupUi(self.MainWindow)

        # Get objects sorted so we can iterate through them
        self._all_objects_ = self._populate_list_of_available_objects_()

        # Prepare BLsetup QT connections
        self.prepare()

        # Now both DE and CV widgets are all updated by a function defined on the bottom class beamline_setup.BL_MainWindow
        # for reasons that that class has access to both APP_Base and APP_GUI
        self.update_all_widgets()

    def update_all_widgets(self):
        # Both DE and CV widgets are all updated by a function defined on the bottom class beamline_setup.BL_MainWindow
        # for reasons that that class has access to both APP_Base and APP_GUI
        pass

    def _populate_list_of_available_objects_(self):
        """
        This will create a dictionary as well as a set of dictionaries for all the objects (QT and beamline Modules)
        """
        self.PB = (
            {}
        )  # QT Push Buttons <-- This comes from the python generated by the QT designer. Names in QT designer need to conform
        self.CB = (
            {}
        )  # QT Check Boxes <-- This comes from the python generated by the QT designer. Names in QT designer need to conform
        self.DE = (
            {}
        )  # QT Date Edits <-- This comes from the python generated by the QT designer. Names in QT designer need to conform
        # ... add more here if you add different widgets in designer
        self.MD = (
            {}
        )  # Instances of classes for the different modules <-- This comes from the loading of modules described on configuration file

        # Now the fun part with getattr :P
        # self.config is not available in this class. Needs to be implemented on subclass main app
        for elem in self.config["modules"]:
            if hasattr(self, f"{elem}_PB"):
                self.PB[elem] = getattr(self, f"{elem}_PB")
                if hasattr(self, f"{elem}_DE"):
                    self.DE[elem] = getattr(self, f"{elem}_DE")
                if hasattr(self, f"{elem}_CB"):
                    self.CB[elem] = getattr(self, f"{elem}_CB")
                self.MD[elem] = getattr(self, f"{elem}_MD")

        # Hide widgets that don't have a module to connect to
        for elem in dir(self):
            split_elem = elem.split("_")
            if (
                len(split_elem) > 1
                and split_elem[1] == "PB"
                and not self.MD.get(split_elem[0])
            ):
                getattr(self, elem).hide()
                if hasattr(self, f"{split_elem[0]}_DE"):
                    getattr(self, f"{split_elem[0]}_DE").hide()
                if hasattr(self, f"{split_elem[0]}_CB"):
                    getattr(self, f"{split_elem[0]}_CB").hide()
                self.MainWindow.resize(
                    self.MainWindow.width(), self.MainWindow.height() - 20
                )

        # The return element is for debugging only as all the values are stored on class variables self.PB, Can be stored on a _var_ if wish
        return {
            "buttons": self.PB,
            "instances": self.MD,
            "check_boxes": self.CB,
            "date_edits": self.DE,
            "names": self.names,
        }

    def test2(self):
        from pprint import pprint

        pprint(self._populate_list_of_available_objects_())

    def prepare(self):
        """
        Setting common gui funcionality
        """
        for task in self.names:
            self.log.debug(task)
            # connect push buttons (PB) to 'run' methods of each instance (MD)
            if f"{task}" in self.MD and f"{task}" in self.PB:
                connection_object = self.PB[task].clicked.connect(
                    self.triggered_from_button(task)
                )
                self.log.debug(
                    f"Connected button {task} to module {task} run method \n this stablishes {connection_object}"
                )

        # Populate Date Edit objects with dates for last run if they are available in redis
        # self.update_all_dateedits()

    def exit(self):
        """
        Close QT application
        """
        self.log.warning("Closing Application")
        QtCore.QCoreApplication.instance().quit()

    def triggered_from_button(self, task):
        """
        Function factory to be able to receive parameters from clicked.connect. This will return a function with the parameters inside
        """

        def call_to_module():
            # If widget2update is a checkbox set half button
            if self.MD[task].widget2update == "CB":
                # self.log.debug(f'Updating checkbox for {task} to half clicked so show I am running')
                self.update_widget(task, status=1, value="db")

            # Running Run method from upstream beamline setup module
            if self.MD[task].run():
                self.log.debug(f"Ok task {task} ran and finished.")
            else:
                self.log.debug(
                    f"Oops task {task} looks to not have finalised correctly."
                )

        return call_to_module

    def updateCB(self, task, status):
        self.CB[task].setCheckState(status)

    def _update_widget_(self, obj, status, widget_type, value="current"):
        """
        Updating QT5 right column widget as well as storing the time in redis when it last ran succesfully
        """
        # Var value needs to be 'current' or a QtCore.QDate object of some kind
        if value == "current":
            value = QtCore.QDateTime.currentDateTime()
        if value == "db":
            value = self.get(f"{obj}_{widget_type}_lastrun")

        self.log.debug(
            f"{obj}: Setting {widget_type} for {obj} to current date and storing to redis"
        )
        self.set(f"{obj}_{widget_type}_lastrun", value)
        self.log.debug(
            f"{obj}: Updating gui widget {widget_type} for task {obj} with new date of {value}"
        )
        if widget_type == "DE":
            if status == 0:
                colour = "red"
            else:
                colour = "black"
            self.log.debug(f"{obj} will be {colour} because status is {status}")
            self.DE[obj].setDateTime(value)
            self.DE[obj].setStyleSheet("QDateEdit { color: %s;}" % (colour))
        elif widget_type == "CB":
            self.CB[obj].setCheckState(status)
            self.log.debug(f"{obj}: current status of CB {self.CB[obj].checkState()}")
        elif widget_type == "CLOSE":
            self.exit()

    def update_all_DEs(self):
        # Updating all dateedits from redis
        for obj in self.DE:
            lastrun = self.get(f"{obj}_DE_lastrun")
            if not lastrun:
                self.log.debug(
                    "redis hash key for storing time for last run is empty. Creating a new one"
                )
                self.set(
                    f"{obj}_DE_lastrun", QtCore.QDateTime.fromSecsSinceEpoch(1553504400)
                )  # default to EPOC for when DGA started working at Diamond :$
                lastrun = self.get(f"{obj}_DE_lastrun")
            self.log.debug(f"{obj}: Going to update {obj} for widget DE with new time")
            self.DE[obj].setDateTime(lastrun)

    def check_criteria4CBs(self, obj, widget_type, lastrun_QTtime):
        self.log.debug(f"{obj} has widget_type: {widget_type}")
        if widget_type == "UNK":
            return -1
        try:
            # criteria = self.MD[obj].criteria2expire
            # Dont want to use self.MD[obj].criteria2expire to keep GUI separated from beamline Modules as much as possible
            criteria = self.config["modules"][obj]["criteria2expire"]
            self.log.debug(f"{obj}: Time offset from configuration is {criteria}")
        except:
            criteria = [0, "second"]
        current_QTtime = QtCore.QDateTime.currentDateTime()
        self.log.debug(f"{obj}: last_run: {lastrun_QTtime}")
        if criteria[1] == "day":
            next_run = lastrun_QTtime.addDays(criteria[0])
        elif criteria[1] == "second":
            next_run = lastrun_QTtime.addSecs(criteria[0])
        elif criteria[1] == "hour":
            next_run = lastrun_QTtime.addSecs(criteria[0] * 60 * 60)
        elif criteria[1] == "minute":
            next_run = lastrun_QTtime.addSecs(criteria[0] * 60)

        if next_run < current_QTtime:
            self.log.debug(
                f"{obj}: Next_run: {next_run} < current_QTtime: {current_QTtime}"
            )
            self.log.debug(
                f"{obj}: Next is before current time. {obj} needs to be run again"
            )
            # 0 = unchecked on CB, red font on DE
            return 0
        else:
            self.log.debug(
                f"{obj}: Next_run: {next_run} => current_QTtime: {current_QTtime}"
            )
            self.log.debug(
                f"{obj}: Next run plus criteria is in the future. {obj} does NOT need to be run again"
            )
            # 2 = fully checked on CB, black font on DE
            return 2
